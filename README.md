# FingerRecognitionFromScratch

2020/12/24 更新：
代码很粗糙，有一些细节需要自己去调试，如果什么都写好直接运行交差，这也没啥意义。
所以希望有缘人能够拿到代码，仔细分析，仔细调试，不要辜负自己的精力和时间吧！思路绝对没问题，每一步都是最原始的代码，最后结果肯定可以确保没问题。而且正是因为粗糙，才会有提升空间，千人千面，希望你能够基于本代码有杰出作品。
我后期会于CSDN开设一下从0开始的课程，敬请期待。

please run main.m to test the code.

Corresponding to the blog article:
1. [指纹识别源代码（1）-图像处理](https://blog.csdn.net/MrCharles/article/details/79292496)
2. [指纹识别源代码（2）-特征点提取](https://blog.csdn.net/MrCharles/article/details/79300671)

如果有任何问题请在Issues中提出

# 指纹采集----》预处理----》特征点提取----》特征点匹配


指纹识别的一般步骤为指纹采集、预处理、特征点提取、特征点匹配。指纹分为螺旋形、弓形、环形。指纹的处理效果影响着后面特征点的提取和识别效果，所以图像的预处理占有重要的地位。指纹采集一般有专业的设备，所以这一步骤一搬不关注。
# 预处理
因为采集指纹时力度和各种因素所以采集的指纹灰度图会有很大不同，首先对图像进行归一化处理，归一化主要针对两个步骤：大小和灰度值。把采集到的指纹图统一调整到特定大小。灰度值我会根据整幅图的均值方差调整到某一范围内。
归一化处理完毕后会对图像进行分割处理，目的是区分出前景色和背景色。我采用的分割为根据多区域阈值分割。多区域分割的效果取决于区域的大小，而指纹的区域分为一脊一谷最好，所以我选择3x3的区域大小。我会根据对区域多次进行求均值和方差进行分割。采集到的指纹图背景的灰度值大于前景色，背景主要为低频，所以背景的方差小于前景的方差。我分别求得背景和前景的均值和方差然后会得到背景为白色 脊线为黑色。然后保存在矩阵e（二值图）中，我会根据e中位置等于1的点的八邻域点的和小于四得到背景色，达到背景和前景分离（e矩阵）。然后黑白反转让感兴趣的前景色变为白色（保存在Icc中），灰度图（gray）的背景值替换为小区域块的和的均值（G1）.但是得到的脊线方向并不能达到准确识别指纹。所以下一步会沿脊线方向增强指纹纹路，采用的方法为基于脊线方向场的增强方法。为了估计脊线的方向场，把脊线的方向场划分为八个方向，然后根据八个方向的灰度值的总和来得到脊线的方向。并对图像进行二值化。此时脊线还是为黑色。因为各种采集原因（油脂水分等）会使指纹粘连断裂，会影响后续的特征提取和识别，接下来会去除指纹中的空洞和毛刺，如果当前位置点值为0（背景）该点的四邻域点（上下左右）的和大于3则为毛刺，空洞的判断方法为该点为白色（背景）的四周为黑色（前景）八领域点两的和为0，则为空洞。我们得到的图像的纹线仍具有一定的宽度，而指纹的识别只与纹线的走向有关。所以我们只需要纹线的宽度为一个像素宽度即可。下面我执行了黑白反转使感兴趣的区域（纹线）变为白色。在执行开操作和闭操作使边界平滑，消除细小的尖刺，断开窄小的连接。执行细化（bwmorph）得到细画图（thin）。
# 特征点提取
特征点提取的点为端点和交叉点，遍历细化图的每一个像素点，端点的判别方法为八领域点两两相减取绝对值求和如果值为2则为端点（周围只有一个为1的白色点）和为6时为交叉点（周围有三值为1的白色点）。把找到的端点位置存储在txy（Nx3）,第一列存储x的位置，第二列存储y的位置，第三列标识点的类别，如果为交叉点则值为6，如果端点则值为2.然后对纹线再次进行光滑处理。原理：找到每个端点，使其沿着纹线的方向移动五个像素，如果在五个像素之内遇到交叉点则此点为毛刺，去除此点。判断离端点num个距离内是否有另一个端点的函数为walk判断的主要方法先将该点置为0然后根据八领域点和；和为0或大于2则证明该点距离num内有端点，然后循环向前遍历。惊醒光滑处理后的特征点比以前少了。但是我们采集指纹时由于采集器的关系，图像的边缘会有很多端点，这已然会影响后续的识别工作，所以我们需要熊特征点中去除这些端点，cut函数主要做这些工作，边缘的主要特征就是黑色多白色少，也就是均值小，所以我主要里用灰度图的分区域（31*31）求均值如果灰度值小于70则在该区域的特征点去除，然后会得到更少的特征点，但这些点依然不够少说明不够特殊，下面定义了combine（thin，r，txy，num）函数可以找出周围半径为r个像素的圆内没有任何端点和交叉点，沿纹线走num个距离没有交叉点和端点，comine为walk和single_point函数的综合，walk函数上面已经介绍，single_point函数主要是找出独特的点作为特征点，原理是根据两个端点之间的距离。求每个端点距离其他端点的距离，找取距离大于r的端点。执行完combine后会得到更少的端点（实验结果为3个端点）。
# 特征点匹配
特征点匹配主要采用三个方法
1.	根据距离判断
找到某一个特征点，从该特征点沿着纹线走num个距离，并计算出每走一步距离该特征点的距离，最后会得到哟个装有长度信息的数组，如果两幅指纹相同则他们含有相同的特征点而且得到的数组对应的位置的数据基本相等
2三角形边长匹配，找到一个特征点以后，可以找出距离最近的两个端点与原特征点构成三角形，若两幅图的三角形的边长比例相等则说明两幅图匹配
3.	点类型匹配
4.	找到一个特征点以后，找出距离最近的num个端点，统计num个端点中端点和交叉点的个数，若两幅图匹配，则端点占的比例大致相同
